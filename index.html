<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chrono Bulward - フェーズ1 弓矢アニメーション</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:block; margin:0 auto; border:2px solid #000; }
  #ui { margin-top:8px; }
  button { margin:4px; padding:8px 16px; font-size:16px; }
</style>
</head>
<body>
<h1>Chrono Bulward - フェーズ1</h1>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="ui">
  <button onclick="chooseUnit('swordsman')">剣士召喚</button>
  <button onclick="chooseUnit('archer')">弓兵召喚</button>
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const lanes = 5;
const laneWidth = canvas.width / lanes;
let playerBaseHP = 100;
let enemyBaseHP = 100;

let playerUnits = [];
let enemyUnits = [];
let projectiles = []; // 矢のリスト
let pendingUnitType = null;

// ユニット定義（さらにスピード半分）
const unitStats = {
  swordsman: { hp: 120, atk: 10, speed: 0.25, type: "melee", color: "blue" },
  archer:    { hp: 80, atk: 8,  speed: 0.25, type: "archer", color: "cyan" },
  goblin:    { hp: 40, atk: 5,  speed: 0.2,  type: "melee", color: "red" }
};

class Unit {
  constructor(type, side, lane, y) {
    this.type = type;
    this.side = side;
    this.lane = lane;
    this.x = lane * laneWidth + laneWidth/2;
    this.y = y;
    this.hp = unitStats[type].hp;
    this.atk = unitStats[type].atk;
    this.speed = unitStats[type].speed;
    this.role = unitStats[type].type;
    this.color = unitStats[type].color;
    this.target = null;
    this.cooldown = 0; // 攻撃間隔管理
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
    ctx.fill();
  }
  update() {
    // 戦闘中なら移動停止
    if (this.target && this.target.hp > 0) return;
    this.target = null;
    if (this.side==="player") this.y -= this.speed;
    else this.y += this.speed;
  }
}

class Projectile {
  constructor(x,y,target,atk) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.atk = atk;
    this.speed = 3;
    this.active = true;
  }
  update() {
    if (!this.target || this.target.hp<=0) { this.active=false; return; }
    let dx = this.target.x - this.x;
    let dy = this.target.y - this.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 5) {
      this.target.hp -= this.atk;
      this.active=false;
    } else {
      this.x += (dx/dist)*this.speed;
      this.y += (dy/dist)*this.speed;
    }
  }
  draw() {
    ctx.strokeStyle="white";
    ctx.beginPath();
    ctx.moveTo(this.x,this.y);
    ctx.lineTo(this.x,this.y-4);
    ctx.stroke();
  }
}

// ボタンで召喚ユニット選択
function chooseUnit(type) {
  pendingUnitType = type;
}

// キャンバスタップでレーン決定
canvas.addEventListener("click", (e)=>{
  if (!pendingUnitType) return;
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const lane = Math.floor(clickX / laneWidth);
  playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40));
  pendingUnitType = null;
});

// 敵スポーン
setInterval(()=>{
  const lane = Math.floor(Math.random()*lanes);
  enemyUnits.push(new Unit("goblin","enemy",lane,40));
},3000);

// 近接戦闘判定
function inMeleeRange(u1,u2,range=25) {
  return (Math.abs(u1.lane - u2.lane) <= 1 && Math.abs(u1.y - u2.y) <= range);
}

// 弓兵の射程判定（縦横3マス以内）
function inArcherRange(u1,u2) {
  return (Math.abs(u1.lane - u2.lane) <= 3 && Math.abs(u1.y - u2.y) <= 120);
}

// メインループ
function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // レーン区切り線
  ctx.strokeStyle="#555";
  for (let i=1;i<lanes;i++) {
    ctx.beginPath();
    ctx.moveTo(i*laneWidth,0);
    ctx.lineTo(i*laneWidth,canvas.height);
    ctx.stroke();
  }

  // HP表示
  ctx.fillStyle="white";
  ctx.font="14px monospace";
  ctx.fillText(`自陣HP:${playerBaseHP}`,10,15);
  ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);

  // 更新・描画
  for (let u of [...playerUnits,...enemyUnits]) {
    u.update();
    u.draw();
  }

  // 戦闘処理
  for (let p of playerUnits) {
    for (let e of enemyUnits) {
      // 近接戦闘
      if (inMeleeRange(p,e)) {
        p.target = e;
        e.target = p;
        p.hp -= e.atk*0.05;
        e.hp -= p.atk*0.05;
      }
      // 弓兵の遠隔攻撃（クールダウン付き）
      if (p.role==="archer" && inArcherRange(p,e)) {
        if (p.cooldown <= 0) {
          projectiles.push(new Projectile(p.x,p.y-12,e,p.atk));
          p.cooldown = 60; // 約1秒のクールダウン
        }
      }
    }
  }

  // クールダウン減少
  for (let p of playerUnits) {
    if (p.cooldown>0) p.cooldown--;
  }

  // 矢の更新・描画
  for (let pr of projectiles) {
    pr.update();
    pr.draw();
  }
  projectiles = projectiles.filter(pr=>pr.active);

  // 死亡処理
  playerUnits = playerUnits.filter(u=>u.hp>0 && u.y>0);
  enemyUnits = enemyUnits.filter(u=>u.hp>0 && u.y<canvas.height);

  // 拠点到達
  for (let e of enemyUnits) {
    if (e.y >= canvas.height-30) { playerBaseHP -= e.atk; e.hp=0; }
  }
  for (let p of playerUnits) {
    if (p.y <= 30) { enemyBaseHP -= p.atk; p.hp=0; }
  }

  // 勝敗判定
  if (playerBaseHP<=0) {
    ctx.fillStyle="red"; ctx.font="30px sans-serif";
    ctx.fillText("GAME OVER",100,300);
    return;
  }
  if (enemyBaseHP<=0) {
    ctx.fillStyle="yellow"; ctx.font="30px sans-serif";
    ctx.fillText("VICTORY!",120,300);
    return;
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
