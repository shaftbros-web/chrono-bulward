<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Chrono Bulward v0.2.27a</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:none; margin:0 auto; border:2px solid #000; }
  #menu { margin-top:20px; }
  h1 { margin:20px; }
  #ui { margin-top:10px; display:none; }
  #ui button { margin:5px; padding:8px 16px; font-size:14px; }
</style>
</head>
<body>
<h1 id="title">Chrono Bulward v0.2.27a</h1>

<div id="menu">
  <button onclick="startGame()">ゲーム開始</button>
</div>

<canvas id="gameCanvas" width="400" height="600"></canvas>

<div id="ui">
  <button onclick="chooseUnit('swordsman')">ナイト召喚</button>
  <button onclick="chooseUnit('archer')">アーチャー召喚</button>
  <button onclick="chooseUnit('healer')">クレリック召喚</button>
</div>

<script>
let unitStats={
  swordsman:{hp:120, atk:10, speed:0.25, range:25},
  archer:{hp:80, atk:8, speed:0.25, range:120},
  healer:{hp:100, atk:10, speed:0.25, range:80},
  goblin:{hp:60, atk:5, speed:0.20, range:25},
  orc:{hp:200, atk:15, speed:0.20, range:25},
  shaman:{hp:120, atk:12, speed:0.25, range:120},
  phantom:{hp:80, atk:10, speed:0.50, range:100},
  golem:{hp:400, atk:20, speed:0.10, range:45}
};

const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
let playerBaseHP,enemyBaseHP,playerUnits,enemyUnits,projectiles,hitMarks,swingMarks;
let pendingUnitType=null;
let enemySpawnTimer=null;

class Unit{
  constructor(type,side,lane,y){
    this.type=type; this.side=side; this.lane=lane;
    this.x=lane*(canvas.width/5)+(canvas.width/10);
    this.y=y;
    const st=unitStats[type];
    this.hp=st.hp; this.atk=st.atk; this.speed=st.speed||0.2; this.range=st.range||25;

    this.role="melee";
    if(type==="archer") this.role="archer";
    if(type==="healer") this.role="healer";
    if(type==="shaman") this.role="shaman";
    if(type==="phantom") this.role="phantom";
    // ★ 修正：敵ゴーレムを遠隔攻撃に変更
    if(type==="golem" && side==="enemy") this.role="golemRanged";

    this.color=(side==="player")?(type==="archer"?"cyan":type==="healer"?"green":"blue"):"red";
    const nameMap={swordsman:"ナ",archer:"弓",healer:"聖",goblin:"ゴ",orc:"オ",shaman:"シ",phantom:"フ",golem:"岩"};
    this.label=nameMap[type]||"?";
    this.target=null; this.cooldown=0;
  }
  draw(){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=(this.side==="player")?"white":"black"; ctx.font="14px sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(this.label,this.x,this.y); }
  update(){ if(this.target){ if(this.target.hp<=0||!inMeleeRange(this,this.target)) this.target=null; else return; }
    this.y+=(this.side==="player"?-this.speed:this.speed); }
}

class Projectile{
  constructor(x,y,target,atk,color="white"){ this.x=x; this.y=y; this.target=target; this.atk=atk; this.speed=3; this.active=true; this.color=color; }
  update(){ if(!this.target||this.target.hp<=0){ this.active=false; return; }
    const dx=this.target.x-this.x,dy=this.target.y-this.y; const d=Math.hypot(dx,dy);
    if(d<5){ this.target.hp-=this.atk; this.active=false; } else { this.x+=(dx/d)*this.speed; this.y+=(dy/d)*this.speed; } }
  draw(){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill(); }
}

function inMeleeRange(a,b){ const laneDiff=Math.abs(a.lane-b.lane); const dy=Math.abs(a.y-b.y);
  if(laneDiff===0) return dy<=24; if(laneDiff===1) return dy<=20; return false; }
function inUnitRange(a,b){ const dx=(a.lane-b.lane)*(canvas.width/5); const dy=(a.y-b.y); return Math.hypot(dx,dy)<=a.range; }

function startGame(){
  document.getElementById("menu").style.display="none"; document.getElementById("title").style.display="none";
  canvas.style.display="block"; document.getElementById("ui").style.display="block";
  playerBaseHP=100; enemyBaseHP=100;
  playerUnits=[]; enemyUnits=[]; projectiles=[]; hitMarks=[]; swingMarks=[];
  if(enemySpawnTimer) clearInterval(enemySpawnTimer);
  enemySpawnTimer=setInterval(spawnEnemy,4000);
  canvas.onclick=(e)=>{ if(!pendingUnitType) return; const rect=canvas.getBoundingClientRect();
    const lane=Math.floor((e.clientX-rect.left)/(canvas.width/5));
    playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40)); pendingUnitType=null; };
  requestAnimationFrame(loop);
}

function spawnEnemy(){
  const lane=Math.floor(Math.random()*5);
  const pool=["goblin","orc","shaman","phantom","golem"];
  const type=pool[Math.floor(Math.random()*pool.length)];
  enemyUnits.push(new Unit(type,"enemy",lane,40));
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#555"; for(let i=1;i<5;i++){ ctx.beginPath(); ctx.moveTo(i*canvas.width/5,0); ctx.lineTo(i*canvas.width/5,canvas.height); ctx.stroke(); }
  ctx.fillStyle="white"; ctx.fillText(`自陣HP:${playerBaseHP}`,10,15); ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);

  for(const u of [...playerUnits,...enemyUnits]){ u.update(); u.draw(); }

  // 自軍攻撃
  for(const p of playerUnits){
    for(const e of enemyUnits){
      if(inMeleeRange(p,e)){ p.target=e; e.target=p; if(p.cooldown<=0){ e.hp-=p.atk; p.cooldown=30; } if(e.cooldown<=0){ p.hp-=e.atk; e.cooldown=40; } }
      else if(p.role==="archer" && inUnitRange(p,e) && p.cooldown<=0){ projectiles.push(new Projectile(p.x,p.y-12,e,p.atk,"white")); p.cooldown=60; }
    }
  }

  // 敵攻撃
  for(const e of enemyUnits){
    if(e.role==="shaman" && e.cooldown<=0 && playerUnits.length>0){
      const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
      if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"purple")); e.cooldown=80; }
    }
    if(e.role==="phantom" && e.cooldown<=0 && playerUnits.length>0){
      const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
      if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"yellow")); e.cooldown=50; }
    }
    // ★ 追加：ゴーレム遠隔攻撃
    if(e.role==="golemRanged" && e.cooldown<=0 && playerUnits.length>0){
      const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
      if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"brown")); e.cooldown=90; }
    }
  }

  for(const u of [...playerUnits,...enemyUnits]) if(u.cooldown>0) u.cooldown--;
  for(const pr of projectiles){ pr.update(); pr.draw(); } projectiles=projectiles.filter(pr=>pr.active);

  playerUnits=playerUnits.filter(u=>u.hp>0&&u.y>0);
  enemyUnits=enemyUnits.filter(u=>u.hp>0&&u.y<canvas.height);
  for(const e of enemyUnits){ if(e.y>=canvas.height-30){ playerBaseHP-=e.atk; e.hp=0; } }
  for(const p of playerUnits){ if(p.y<=30){ enemyBaseHP-=p.atk; p.hp=0; } }

  if(playerBaseHP<=0){ endScreen("GAME OVER","red"); return; }
  if(enemyBaseHP<=0){ endScreen("VICTORY!","yellow"); return; }
  requestAnimationFrame(loop);
}

function endScreen(text,color){ if(enemySpawnTimer){ clearInterval(enemySpawnTimer); enemySpawnTimer=null; }
  ctx.fillStyle=color; ctx.font="30px sans-serif"; ctx.fillText(text,120,300); }

function chooseUnit(type){ pendingUnitType=type; }
</script>
</body>
</html>
