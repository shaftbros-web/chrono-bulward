<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chrono Bulward - フェーズ1 (レーン指定召喚)</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:block; margin:0 auto; border:2px solid #000; }
  #ui { margin-top:8px; }
  button { margin:4px; padding:8px 16px; font-size:16px; }
</style>
</head>
<body>
<h1>Chrono Bulward - フェーズ1</h1>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="ui">
  <button onclick="chooseUnit('swordsman')">剣士召喚</button>
  <button onclick="chooseUnit('archer')">弓兵召喚</button>
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const lanes = 5;
const laneWidth = canvas.width / lanes;
let playerBaseHP = 100;
let enemyBaseHP = 100;

let playerUnits = [];
let enemyUnits = [];
let pendingUnitType = null; // ボタンで選んだユニットタイプを記録

// ユニット定義
const unitStats = {
  swordsman: { hp: 120, atk: 10, speed: 1, type: "melee", color: "blue" },
  archer:    { hp: 80, atk: 8, speed: 1, type: "archer", color: "cyan" },
  goblin:    { hp: 40, atk: 5, speed: 0.8, type: "melee", color: "red" }
};

class Unit {
  constructor(type, side, lane, y) {
    this.type = type;
    this.side = side; // "player" or "enemy"
    this.lane = lane; // 0〜4
    this.x = lane * laneWidth + laneWidth/2;
    this.y = y;
    this.hp = unitStats[type].hp;
    this.atk = unitStats[type].atk;
    this.speed = unitStats[type].speed;
    this.role = unitStats[type].type;
    this.color = unitStats[type].color;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
    ctx.fill();
  }
  update() {
    if (this.side==="player") this.y -= this.speed;
    else this.y += this.speed;
  }
}

// ボタンで召喚ユニット選択
function chooseUnit(type) {
  pendingUnitType = type;
}

// キャンバスタップでレーン決定
canvas.addEventListener("click", (e)=>{
  if (!pendingUnitType) return;
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const lane = Math.floor(clickX / laneWidth);
  playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40));
  pendingUnitType = null; // 召喚済みでリセット
});

// 敵スポーン（ランダムレーン）
setInterval(()=>{
  const lane = Math.floor(Math.random()*lanes);
  enemyUnits.push(new Unit("goblin","enemy",lane,40));
},2000);

// 近接戦闘判定（同じ/隣接レーンで接近）
function inMeleeRange(u1,u2,range=25) {
  return (Math.abs(u1.lane - u2.lane) <= 1 && Math.abs(u1.y - u2.y) <= range);
}

// 弓兵の射程判定（縦横3マス ≒ 3レーン以内・縦距離も120px以内）
function inArcherRange(u1,u2) {
  return (Math.abs(u1.lane - u2.lane) <= 3 && Math.abs(u1.y - u2.y) <= 120);
}

// メインループ
function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // レーン区切り線
  ctx.strokeStyle="#555";
  for (let i=1;i<lanes;i++) {
    ctx.beginPath();
    ctx.moveTo(i*laneWidth,0);
    ctx.lineTo(i*laneWidth,canvas.height);
    ctx.stroke();
  }

  // HP表示
  ctx.fillStyle="white";
  ctx.font="14px monospace";
  ctx.fillText(`自陣HP:${playerBaseHP}`,10,15);
  ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);

  // 更新・描画
  for (let u of [...playerUnits,...enemyUnits]) {
    u.update();
    u.draw();
  }

  // 戦闘処理
  for (let p of playerUnits) {
    for (let e of enemyUnits) {
      // 剣士 vs ゴブリン（近接）
      if (p.role==="melee" && inMeleeRange(p,e)) {
        p.hp -= e.atk*0.05;
        e.hp -= p.atk*0.05;
      }
      // 弓兵の遠隔攻撃
      if (p.role==="archer" && inArcherRange(p,e)) {
        e.hp -= p.atk*0.02;
      }
      // ゴブリン vs プレイヤー（近接）
      if (e.role==="melee" && inMeleeRange(p,e)) {
        p.hp -= e.atk*0.05;
        e.hp -= p.atk*0.05;
      }
    }
  }

  // 死亡処理
  playerUnits = playerUnits.filter(u=>u.hp>0 && u.y>0);
  enemyUnits = enemyUnits.filter(u=>u.hp>0 && u.y<canvas.height);

  // 拠点到達
  for (let e of enemyUnits) {
    if (e.y >= canvas.height-30) { playerBaseHP -= e.atk; e.hp=0; }
  }
  for (let p of playerUnits) {
    if (p.y <= 30) { enemyBaseHP -= p.atk; p.hp=0; }
  }

  // 勝敗判定
  if (playerBaseHP<=0) {
    ctx.fillStyle="red"; ctx.font="30px sans-serif";
    ctx.fillText("GAME OVER",100,300);
    return;
  }
  if (enemyBaseHP<=0) {
    ctx.fillStyle="yellow"; ctx.font="30px sans-serif";
    ctx.fillText("VICTORY!",120,300);
    return;
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
