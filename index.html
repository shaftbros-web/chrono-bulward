<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Chrono Bulward v0.2.34</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:none; margin:0 auto; border:2px solid #000; }
  #menu, #settings, #help { margin-top:20px; }
  h1 { margin:20px; }
  .unit-settings { border:1px solid #555; padding:10px; margin:10px auto; width:90%; max-width:460px; text-align:left; }
  input[type=range] { width:260px; }
  #ui { margin-top:10px; display:none; }
  #ui button { margin:5px; padding:8px 16px; font-size:14px; }
  #help, #settings { display:none; text-align:left; max-width:720px; margin:20px auto; padding:12px; background:#111; border:1px solid #555; }
  h3 { cursor:pointer; margin:10px 0; }
</style>
</head>
<body>
<h1 id="title">Chrono Bulward v0.2.34</h1>

<div id="menu">
  <button onclick="startGame()">ゲーム開始</button>
  <button onclick="showSettings()">設定</button>
  <button onclick="showHelp()">説明</button>
</div>

<div id="settings">
  <h2>ユニット調整（キャラ名クリックで単体出現モード選択）</h2>
  <div id="unitSliders"></div>
  <div style="margin-top:8px;">
    <button onclick="backToMenu()">戻る</button>
    <button onclick="applySettingsAndStart()">ゲーム開始</button>
  </div>
</div>

<div id="help">
  <h2>ゲームのルール</h2>
  <p>自陣（下）からユニットを召喚し、敵陣（上）から進行してくる敵を防ぎます。<br>
  ユニット同士が接触すると戦闘開始、どちらかが倒れるまで移動を停止して戦闘を続けます。</p>
  <h2>主要ユニット</h2>
  <ul>
    <li>ナイト：近接</li>
    <li>アーチャー：遠距離</li>
    <li>クレリック：回復</li>
    <li>ゴーレム：敵専用・岩投げ</li>
    <li>巨大オーガ：ボス・近接</li>
    <li>邪竜：ボス・炎ブレス遠隔</li>
  </ul>
  <button onclick="backToMenuFromHelp()">戻る</button>
</div>

<canvas id="gameCanvas" width="400" height="600"></canvas>

<div id="ui">
  <button onclick="chooseUnit('swordsman')">ナイト召喚</button>
  <button onclick="chooseUnit('archer')">アーチャー召喚</button>
  <button onclick="chooseUnit('healer')">クレリック召喚</button>
</div>

<script>
let singleSpawnUnit = null;

let unitStats = {
  swordsman:{hp:120, atk:10, speed:0.25, range:25},
  archer:{hp:80, atk:8, speed:0.25, range:120},
  healer:{hp:100, atk:10, speed:0.25, range:80},
  goblin:{hp:60, atk:5, speed:0.20, range:25},
  orc:{hp:200, atk:15, speed:0.20, range:25},
  shaman:{hp:120, atk:12, speed:0.25, range:120},
  phantom:{hp:80, atk:10, speed:0.50, range:100},
  golem:{hp:400, atk:20, speed:0.10, range:45},
  ogre:{hp:1500, atk:40, speed:0.10, range:30},
  dragon:{hp:3000, atk:70, speed:0.15, range:120}
};

// 設定UI生成（省略）…ここは前回のv0.2.34と同じ

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let playerBaseHP, enemyBaseHP, playerUnits, enemyUnits, projectiles, hitMarks, swingMarks;
let pendingUnitType = null;
let enemySpawnTimer = null;

// ==== クラス定義（Unit, Projectileなど） ====
// （ここも v0.2.34 前回コードと同じなので省略可能ですが、loopの前まで全部含めます）
  // ==== 各種クラス続き ====

class Projectile{
  constructor(x,y,target,atk,color="white"){
    this.x=x; this.y=y; this.target=target;
    this.atk=atk; this.color=color;
    this.speed=3; this.active=true;
  }
  update(){
    if(!this.target || this.target.hp<=0){ this.active=false; return; }
    const dx=this.target.x-this.x, dy=this.target.y-this.y;
    const d=Math.hypot(dx,dy);
    if(d<5){
      this.target.hp-=this.atk;
      hitMarks.push(new HitMark(this.target.x,this.target.y));
      this.active=false;
    } else {
      this.x += (dx/d)*this.speed;
      this.y += (dy/d)*this.speed;
    }
  }
  draw(){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill(); }
}

class HealProjectile{
  constructor(x,y,target,amount){
    this.x=x; this.y=y; this.target=target;
    this.amount=amount; this.speed=3; this.active=true;
  }
  update(){
    if(!this.target || this.target.hp<=0){ this.active=false; return; }
    const dx=this.target.x-this.x, dy=this.target.y-this.y;
    const d=Math.hypot(dx,dy);
    if(d<5){
      this.target.hp += this.amount;
      hitMarks.push(new HealMark(this.target.x,this.target.y));
      this.active=false;
    } else {
      this.x += (dx/d)*this.speed;
      this.y += (dy/d)*this.speed;
    }
  }
  draw(){ ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill(); }
}

class HitMark{
  constructor(x,y){ this.x=x; this.y=y; this.life=15; }
  update(){ this.life--; }
  draw(){
    ctx.lineWidth=3; ctx.strokeStyle="red";
    ctx.beginPath(); ctx.moveTo(this.x-8,this.y-8); ctx.lineTo(this.x+8,this.y+8);
    ctx.moveTo(this.x+8,this.y-8); ctx.lineTo(this.x-8,this.y+8); ctx.stroke();
    ctx.lineWidth=1;
  }
}
class HealMark{
  constructor(x,y){ this.x=x; this.y=y; this.life=15; }
  update(){ this.life--; }
  draw(){
    ctx.strokeStyle="lime"; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(this.x,this.y,14,0,Math.PI*2); ctx.stroke();
    ctx.lineWidth=1;
  }
}
class SwingMark{
  constructor(x,y,side){ this.x=x; this.y=y; this.life=12; this.side=side; }
  update(){ this.life--; }
  draw(){
    ctx.save(); ctx.lineWidth=3;
    ctx.strokeStyle=(this.side==="player")?"#88f":"#f88";
    ctx.beginPath(); ctx.arc(this.x,this.y,16,-Math.PI/3,0); ctx.stroke();
    ctx.beginPath(); ctx.arc(this.x,this.y,12,0,Math.PI/3); ctx.stroke();
    ctx.restore();
  }
}

// ==== 判定関数 ====
function inMeleeRange(a,b){
  const laneDiff=Math.abs(a.lane-b.lane);
  const dy=Math.abs(a.y-b.y);
  if(laneDiff===0) return dy<=24;
  if(laneDiff===1) return dy<=20;
  return false;
}
function inUnitRange(a,b){
  const dx=(a.lane-b.lane)*(canvas.width/5);
  const dy=(a.y-b.y);
  return Math.hypot(dx,dy) <= a.range;
}

// ==== ゲーム開始 ====
function startGame(){
  document.getElementById("menu").style.display="none";
  document.getElementById("settings").style.display="none";
  document.getElementById("help").style.display="none";
  document.getElementById("title").style.display="none";
  canvas.style.display="block";
  document.getElementById("ui").style.display="block";

  playerBaseHP=100; enemyBaseHP=100;
  playerUnits=[]; enemyUnits=[]; projectiles=[]; hitMarks=[]; swingMarks=[];
  if(enemySpawnTimer) clearInterval(enemySpawnTimer);
  enemySpawnTimer=setInterval(spawnEnemy,4000);

  canvas.onclick=(e)=>{
    if(!pendingUnitType) return;
    const rect=canvas.getBoundingClientRect();
    const lane=Math.floor((e.clientX-rect.left)/(canvas.width/5));
    playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40));
    pendingUnitType=null;
  };

  requestAnimationFrame(loop);
}

// ==== 敵出現 ====
function spawnEnemy(){
  if(singleSpawnUnit){
    const lane=2; // 中央レーン固定
    enemyUnits.push(new Unit(singleSpawnUnit,"enemy",lane,40));
    if(enemySpawnTimer){ clearInterval(enemySpawnTimer); enemySpawnTimer=null; }
    return;
  }
  const lane=Math.floor(Math.random()*5);
  const pool=["goblin","orc","golem","shaman","phantom"]; // ボス除外
  const type=pool[Math.floor(Math.random()*pool.length)];
  enemyUnits.push(new Unit(type,"enemy",lane,40));
}

// ==== メインループ ====
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle="#555";
  for(let i=1;i<5;i++){ ctx.beginPath(); ctx.moveTo(i*canvas.width/5,0); ctx.lineTo(i*canvas.width/5,canvas.height); ctx.stroke(); }

  ctx.fillStyle="white";
  ctx.fillText(`自陣HP:${playerBaseHP}`,10,15);
  ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);

  for(const u of [...playerUnits,...enemyUnits]){ u.update(); u.draw(); }

  // === 自軍行動 ===
  for(const p of playerUnits){
    for(const e of enemyUnits){
      if(inMeleeRange(p,e)){
        p.target=e; e.target=p;
        if(p.cooldown<=0){
          e.hp-=p.atk; hitMarks.push(new HitMark(e.x,e.y)); swingMarks.push(new SwingMark(p.x,p.y,"player")); p.cooldown=30;
        }
        if(e.cooldown<=0){
          p.hp-=e.atk; hitMarks.push(new HitMark(p.x,p.y)); swingMarks.push(new SwingMark(e.x,e.y,"enemy")); e.cooldown=40;
        }
      }else{
        if(p.role==="archer" && inUnitRange(p,e) && p.cooldown<=0){
          projectiles.push(new Projectile(p.x,p.y-12,e,p.atk,"white")); p.cooldown=60;
        }
      }
    }
    if(p.role==="healer" && p.cooldown<=0){
      for(const ally of playerUnits){
        if(ally!==p && ally.hp>0 && ally.hp<unitStats[ally.type].hp && inUnitRange(p,ally)){
          projectiles.push(new HealProjectile(p.x,p.y-12,ally,p.atk));
          p.cooldown=90; break;
        }
      }
    }
  }

  // === 敵行動 ===
  for(const e of enemyUnits){
    if(e.target && e.target.hp>0){
      // 近接戦中
    }else{
      if(e.role==="shaman" && e.cooldown<=0 && playerUnits.length>0){
        const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
        if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"purple")); e.cooldown=80; }
      }
      if(e.role==="phantom" && e.cooldown<=0 && playerUnits.length>0){
        const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
        if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"yellow")); e.cooldown=50; }
      }
      if(e.role==="golemRanged" && e.cooldown<=0 && playerUnits.length>0){
        const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
        if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"brown")); e.cooldown=90; }
      }
      if(e.role==="dragonRanged" && e.cooldown<=0 && playerUnits.length>0){
        const t=playerUnits[Math.floor(Math.random()*playerUnits.length)];
        if(inUnitRange(e,t)){ projectiles.push(new Projectile(e.x,e.y+12,t,e.atk,"orange")); e.cooldown=60; }
      }
    }
  }

  // === クールダウン更新 ===
  for(const u of [...playerUnits,...enemyUnits]) if(u.cooldown>0) u.cooldown--;

  // === 飛翔体・演出 ===
  for(const pr of projectiles){ pr.update(); pr.draw(); }
  projectiles=projectiles.filter(pr=>pr.active);

  for(const h of hitMarks){ h.update(); h.draw(); }
  hitMarks=hitMarks.filter(h=>h.life>0);

  for(const s of swingMarks){ s.update(); s.draw(); }
  swingMarks=swingMarks.filter(s=>s.life>0);

  // === ベース到達 ===
  playerUnits=playerUnits.filter(u=>u.hp>0 && u.y>0);
  enemyUnits=enemyUnits.filter(u=>u.hp>0 && u.y<canvas.height);

  for(const e of enemyUnits){ if(e.y>=canvas.height-30){ playerBaseHP-=e.atk; e.hp=0; } }
  for(const p of playerUnits){ if(p.y<=30){ enemyBaseHP-=p.atk; p.hp=0; } }

  // === 勝敗 ===
  if(playerBaseHP<=0){ endScreen("GAME OVER","red"); return; }
  if(enemyBaseHP<=0){ endScreen("VICTORY!","yellow"); return; }

  requestAnimationFrame(loop);
}

function endScreen(text,color){
  if(enemySpawnTimer){ clearInterval(enemySpawnTimer); enemySpawnTimer=null; }
  ctx.fillStyle=color; ctx.font="30px sans-serif";
  ctx.fillText(text,120,300);
}

function chooseUnit(type){ pendingUnitType=type; }
</script>
</body>
</html>
