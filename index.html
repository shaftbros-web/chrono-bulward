<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chrono Bulward v0.2.9</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:none; margin:0 auto; border:2px solid #000; }
  #menu, #settings { margin-top:20px; }
  h1 { margin:20px; }
  h2 { margin-top:30px; }
  .unit-settings { border:1px solid #555; padding:10px; margin:10px auto; width:90%; max-width:400px; text-align:left; }
  input[type=range] { width:200px; }
  #ui { margin-top:10px; display:none; }
  #ui button { margin:5px; padding:8px 16px; font-size:14px; }
</style>
</head>
<body>
<h1 id="title">Chrono Bulward v0.2.9</h1>

<!-- タイトルメニュー -->
<div id="menu">
  <button onclick="startGame()">ゲーム開始</button>
  <button onclick="showSettings()">設定</button>
</div>

<!-- 設定画面 -->
<div id="settings" style="display:none;">
  <h2>ユニット調整</h2>
  <div id="unitSliders"></div>
  <br>
  <button onclick="backToMenu()">戻る</button>
  <button onclick="applySettingsAndStart()">ゲーム開始</button>
</div>

<!-- ゲームキャンバス -->
<canvas id="gameCanvas" width="400" height="600"></canvas>

<!-- ゲームUI（召喚ボタン） -->
<div id="ui">
  <button onclick="chooseUnit('swordsman')">剣士召喚</button>
  <button onclick="chooseUnit('archer')">弓兵召喚</button>
  <button onclick="chooseUnit('healer')">回復役召喚</button>
</div>

<script>
/* =====================
   Chrono Bulward v0.2.9
   回復の射程制限修正版
===================== */
let unitStats = {
  swordsman:{hp:120, atk:10, speed:0.25, range:25},
  archer:{hp:80, atk:8, speed:0.25, range:80},
  healer:{hp:100, atk:10, speed:0.25, range:80},
  goblin:{hp:60, atk:5, speed:0.2, range:25},
  orc:{hp:200, atk:15, speed:0.2, range:25},
  golem:{hp:400, atk:20, speed:0.1, range:25},
  shaman:{hp:120, atk:12, speed:0.25, range:90},
  phantom:{hp:80, atk:10, speed:0.5, range:70},
  ogre:{hp:600, atk:40, range:40},
  dragon:{hp:1500, atk:100, range:80}
};

/* =====================
   設定画面スライダー
===================== */
const unitConfig = {
  swordsman:{name:"剣士", props:{hp:[50,300], atk:[5,30], speed:[0.1,1,0.05], range:[10,100]}},
  archer:{name:"弓兵", props:{hp:[40,200], atk:[5,30], speed:[0.1,1,0.05], range:[30,150]}},
  healer:{name:"回復役", props:{hp:[40,200], atk:[5,30], speed:[0.1,1,0.05], range:[30,150]}},
  goblin:{name:"ゴブリン", props:{hp:[20,200], atk:[2,20], speed:[0.1,1,0.05], range:[10,100]}},
  orc:{name:"オーク", props:{hp:[100,500], atk:[10,50], speed:[0.05,0.5,0.05], range:[10,100]}},
  golem:{name:"ゴーレム", props:{hp:[200,1000], atk:[10,50], speed:[0.05,0.3,0.05], range:[10,100]}},
  shaman:{name:"シャーマン", props:{hp:[50,250], atk:[5,30], speed:[0.1,0.5,0.05], range:[50,150]}},
  phantom:{name:"ファントム", props:{hp:[30,150], atk:[5,25], speed:[0.2,1,0.05], range:[30,120]}},
  ogre:{name:"巨大オーガ(ボス)", props:{hp:[200,2000], atk:[20,200], range:[20,200]}},
  dragon:{name:"邪竜(ボス)", props:{hp:[500,5000], atk:[50,500], range:[50,500]}}
};

const unitSlidersDiv = document.getElementById("unitSliders");
for (let key in unitConfig){
  let html = `<div class="unit-settings"><h3>${unitConfig[key].name}</h3>`;
  for (let prop in unitConfig[key].props){
    let range = unitConfig[key].props[prop];
    let min=range[0], max=range[1], step=range[2]||1;
    let val = unitStats[key][prop];
    html += `${prop.toUpperCase()}: 
      <input type="range" id="${key}_${prop}" min="${min}" max="${max}" step="${step}" value="${val}" 
        oninput="updateLabel('${key}_${prop}')">
      <span id="${key}_${prop}_val">${val}</span><br>`;
  }
  html += "</div>";
  unitSlidersDiv.innerHTML += html;
}
function updateLabel(id){ document.getElementById(id+"_val").innerText = document.getElementById(id).value; }
function showSettings(){ document.getElementById("menu").style.display="none"; document.getElementById("settings").style.display="block"; }
function backToMenu(){ document.getElementById("settings").style.display="none"; document.getElementById("menu").style.display="block"; }
function applySettingsAndStart(){
  for (let key in unitStats){
    for (let prop in unitStats[key]){
      let id = `${key}_${prop}`;
      if (document.getElementById(id)){
        let val = document.getElementById(id).value;
        unitStats[key][prop] = parseFloat(val);
      }
    }
  }
  startGame();
}

/* =====================
   ゲーム本体
===================== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let playerBaseHP, enemyBaseHP, playerUnits, enemyUnits, projectiles, hitMarks;
let pendingUnitType=null;

/* --- クラス定義 --- */
class Unit {
  constructor(type, side, lane, y){
    this.type=type; this.side=side; this.lane=lane;
    this.x=lane*(canvas.width/5)+(canvas.width/10);
    this.y=y;
    this.hp=unitStats[type].hp;
    this.atk=unitStats[type].atk;
    this.speed=unitStats[type].speed||0.2;
    this.range=unitStats[type].range||25;
    this.role=(type==="archer")?"archer":(type==="healer")?"healer":"melee";
    if(type==="shaman") this.role="shaman";
    if(type==="phantom") this.role="phantom";

    this.color=(side==="player")? 
      (type==="archer"?"cyan":type==="healer"?"green":"blue") 
      :"red";

    const nameMap = {
      swordsman:"剣", archer:"弓", healer:"回",
      goblin:"ゴ", orc:"オ", golem:"ゴレ",
      shaman:"シ", phantom:"フ", ogre:"巨", dragon:"竜"
    };
    this.label = nameMap[type] || "?";

    this.target=null; this.cooldown=0;
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,12,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = (this.side==="player") ? "white" : "black";
    ctx.font="14px sans-serif";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(this.label, this.x, this.y);
  }
  update(){
    if(this.target){
      if(this.target.hp <= 0 || !inUnitRange(this,this.target)){
        this.target = null;
      } else {
        return; // 戦闘中／射程内は停止
      }
    }
    if(this.side==="player") this.y-=this.speed; else this.y+=this.speed;
  }
}

/* Projectile系クラス */
class Projectile {
  constructor(x,y,target,atk,color="white"){ 
    this.x=x; this.y=y; this.target=target; this.atk=atk; 
    this.speed=3; this.active=true; this.color=color; 
  }
  update(){
    if(!this.target||this.target.hp<=0){this.active=false; return;}
    let dx=this.target.x-this.x, dy=this.target.y-this.y; 
    let dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<5){ 
      this.target.hp-=this.atk; 
      hitMarks.push(new HitMark(this.target.x,this.target.y)); 
      this.active=false; 
    }
    else{ this.x+=(dx/dist)*this.speed; this.y+=(dy/dist)*this.speed; }
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,4,0,Math.PI*2);
    ctx.fill();
  }
}
class HealProjectile {
  constructor(x,y,target,amount){ this.x=x; this.y=y; this.target=target; this.amount=amount; this.speed=3; this.active=true; }
  update(){
    if(!this.target||this.target.hp<=0){ this.active=false; return; }
    let dx=this.target.x-this.x, dy=this.target.y-this.y; let dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<5){ this.target.hp += this.amount; hitMarks.push(new HealMark(this.target.x,this.target.y)); this.active=false; }
    else{ this.x+=(dx/dist)*this.speed; this.y+=(dy/dist)*this.speed; }
  }
  draw(){ ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill(); }
}
class HitMark { constructor(x,y){ this.x=x; this.y=y; this.life=15; }
  update(){ this.life--; }
  draw(){ ctx.lineWidth=3; ctx.strokeStyle="red";
    ctx.beginPath(); ctx.moveTo(this.x-8,this.y-8); ctx.lineTo(this.x+8,this.y+8);
    ctx.moveTo(this.x+8,this.y-8); ctx.lineTo(this.x-8,this.y+8); ctx.stroke(); ctx.lineWidth=1; } }
class HealMark { constructor(x,y){ this.x=x; this.y=y; this.life=15; }
  update(){ this.life--; }
  draw(){ ctx.strokeStyle="lime"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x,this.y,14,0,Math.PI*2); ctx.stroke(); ctx.lineWidth=1; } }

/* =====================
   射程判定
===================== */
function inMeleeRange(u1,u2){ 
  let sameLane = (u1.lane === u2.lane) || (Math.abs(u1.lane - u2.lane) === 1);
  let dy = Math.abs(u1.y - u2.y);
  return sameLane && dy <= 20;
}
function inUnitRange(u1,u2){
  let dx = (u1.lane - u2.lane) * (canvas.width/5);
  let dy = u1.y - u2.y;
  let dist = Math.sqrt(dx*dx + dy*dy);
  return dist <= u1.range;
}

/* =====================
   ゲームループ
===================== */
function startGame(){
  document.getElementById("menu").style.display="none";
  document.getElementById("settings").style.display="none";
  document.getElementById("title").style.display="none";
  canvas.style.display="block";
  document.getElementById("ui").style.display="block";

  playerBaseHP=100; enemyBaseHP=100;
  playerUnits=[]; enemyUnits=[]; projectiles=[]; hitMarks=[];

  canvas.onclick=(e)=>{
    if(!pendingUnitType)return;
    let lane=Math.floor((e.clientX-canvas.getBoundingClientRect().left)/(canvas.width/5));
    playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40));
    pendingUnitType=null;
  };

  setInterval(()=>{
    const enemyTypes=["goblin","orc","golem","shaman","phantom"];
    let type = enemyTypes[Math.floor(Math.random()*enemyTypes.length)];
    let lane=Math.floor(Math.random()*5);
    enemyUnits.push(new Unit(type,"enemy",lane,40));
  },4000);

  loop();
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#555";
  for(let i=1;i<5;i++){ ctx.beginPath(); ctx.moveTo(i*canvas.width/5,0); ctx.lineTo(i*canvas.width/5,canvas.height); ctx.stroke(); }
  ctx.fillStyle="white"; ctx.fillText(`自陣HP:${playerBaseHP}`,10,15); ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);

  for(let u of [...playerUnits,...enemyUnits]){ u.update(); u.draw(); }

  for(let p of playerUnits){
    for(let e of enemyUnits){
      if(inMeleeRange(p,e)){
        p.target=e; e.target=p;
        if(p.cooldown<=0){ e.hp-=p.atk; hitMarks.push(new HitMark(e.x,e.y)); p.cooldown=30; }
        if(e.cooldown<=0){ p.hp-=e.atk; hitMarks.push(new HitMark(p.x,p.y)); e.cooldown=40; }
      } else {
        if(p.role==="archer" && inUnitRange(p,e) && p.cooldown<=0){
          projectiles.push(new Projectile(p.x,p.y-12,e,p.atk,"white"));
          p.cooldown=60;
        }
      }
    }
    // ★ 回復の射程制限を追加
    if(p.role==="healer" && p.cooldown<=0){
      for(let ally of playerUnits){
        if(ally!==p && ally.hp>0 && ally.hp<unitStats[ally.type].hp && inUnitRange(p,ally)){
          projectiles.push(new HealProjectile(p.x,p.y-12,ally,p.atk));
          p.cooldown=90;
        }
      }
    }
  }

  for(let e of enemyUnits){
    if(e.target && e.target.hp>0){
    } else {
      if(e.role==="shaman" && e.cooldown<=0){
        if(playerUnits.length>0){
          let target=playerUnits[Math.floor(Math.random()*playerUnits.length)];
          if(inUnitRange(e,target)){
            projectiles.push(new Projectile(e.x,e.y+12,target,e.atk,"purple"));
            e.cooldown=80;
          }
        }
      }
      if(e.role==="phantom" && e.cooldown<=0){
        if(playerUnits.length>0){
          let target=playerUnits[Math.floor(Math.random()*playerUnits.length)];
          if(inUnitRange(e,target)){
            projectiles.push(new Projectile(e.x,e.y+12,target,e.atk,"yellow"));
            e.cooldown=50;
          }
        }
      }
    }
  }

  for(let u of [...playerUnits,...enemyUnits]) if(u.cooldown>0) u.cooldown--;

  for(let pr of projectiles){ pr.update(); pr.draw(); }
  projectiles=projectiles.filter(pr=>pr.active);
  for(let h of hitMarks){ h.update(); h.draw(); }
  hitMarks=hitMarks.filter(h=>h.life>0);

  playerUnits=playerUnits.filter(u=>u.hp>0&&u.y>0);
  enemyUnits=enemyUnits.filter(u=>u.hp>0&&u.y<canvas.height);

  for(let e of enemyUnits){ if(e.y>=canvas.height-30){ playerBaseHP-=e.atk; e.hp=0; } }
  for(let p of playerUnits){ if(p.y<=30){ enemyBaseHP-=p.atk; p.hp=0; } }

  if(playerBaseHP<=0){ ctx.fillStyle="red"; ctx.font="30px sans-serif"; ctx.fillText("GAME OVER",100,300); return; }
  if(enemyBaseHP<=0){ ctx.fillStyle="yellow"; ctx.font="30px sans-serif"; ctx.fillText("VICTORY!",120,300); return; }

  requestAnimationFrame(loop);
}

function chooseUnit(type){ pendingUnitType=type; }
</script>
</body>
</html>
