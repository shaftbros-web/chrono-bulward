<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chrono Bulward v0.2.22</title>
<style>
  body { margin:0; background:#222; color:#eee; font-family:monospace; text-align:center; }
  #gameCanvas { background:#333; display:none; margin:0 auto; border:2px solid #000; }
  #menu, #help { margin-top:20px; }
  h1 { margin:20px; }
  #ui { margin-top:10px; display:none; }
  #ui button { margin:5px; padding:8px 16px; font-size:14px; }
  #help { display:none; text-align:left; max-width:600px; margin:20px auto; padding:10px; background:#111; border:1px solid #555; }
</style>
</head>
<body>
<h1 id="title">Chrono Bulward v0.2.22</h1>

<div id="menu">
  <button onclick="startGame()">ゲーム開始</button>
  <button onclick="showHelp()">説明</button>
</div>

<!-- ★説明画面追加 -->
<div id="help">
  <h2>ゲームのルール</h2>
  <p>自陣（下）からユニットを召喚し、敵陣（上）から進行してくる敵を防ぎます。<br>
  ユニット同士が接触すると戦闘開始、どちらかが倒れるまで動きません。</p>

  <h2>勝敗条件</h2>
  <ul>
    <li>敵ユニットが自陣に到達すると自陣HPが減少</li>
    <li>味方ユニットが敵陣に到達すると敵陣HPが減少</li>
    <li>どちらかのHPが0になると勝敗が決まります</li>
  </ul>

  <h2>キャラクター</h2>
  <ul>
    <li><b>ナイト</b>：近接戦闘。標準的なユニット</li>
    <li><b>アーチャー</b>：遠距離攻撃。射程あり</li>
    <li><b>クレリック</b>：回復役。味方を癒す</li>
    <li><b>ゴブリン</b>：雑兵。耐久低め</li>
    <li><b>オーク</b>：耐久力が高い敵</li>
    <li><b>シャーマン</b>：敵の遠隔魔法攻撃</li>
    <li><b>ファントム</b>：高速の遠隔攻撃</li>
    <li><b>ゴーレム</b>：タフな大型敵</li>
  </ul>

  <button onclick="backToMenu()">戻る</button>
</div>

<canvas id="gameCanvas" width="400" height="600"></canvas>

<div id="ui">
  <button onclick="chooseUnit('swordsman')">ナイト召喚</button>
  <button onclick="chooseUnit('archer')">アーチャー召喚</button>
  <button onclick="chooseUnit('healer')">クレリック召喚</button>
</div>

<script>
/* =====================
   Chrono Bulward v0.2.22
   0.2.13ベース＋説明画面
===================== */

let unitStats = {
  swordsman:{hp:120, atk:10, speed:0.25, range:25},
  archer:{hp:80, atk:8, speed:0.25, range:120},
  healer:{hp:100, atk:10, speed:0.25, range:80},
  goblin:{hp:60, atk:5, speed:0.2, range:25},
  orc:{hp:200, atk:15, speed:0.2, range:25},
  shaman:{hp:120, atk:12, speed:0.25, range:120},
  phantom:{hp:80, atk:10, speed:0.5, range:100},
  golem:{hp:400, atk:20, speed:0.1, range:25}
};

// UI切替
function showHelp(){document.getElementById("menu").style.display="none";document.getElementById("help").style.display="block";}
function backToMenu(){document.getElementById("help").style.display="none";document.getElementById("menu").style.display="block";}

const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
let playerBaseHP, enemyBaseHP, playerUnits, enemyUnits, projectiles, hitMarks, swingMarks;
let pendingUnitType=null;

class Unit {
  constructor(type, side, lane, y){
    this.type=type; this.side=side; this.lane=lane;
    this.x=lane*(canvas.width/5)+(canvas.width/10);
    this.y=y;
    this.hp=unitStats[type].hp;
    this.atk=unitStats[type].atk;
    this.speed=unitStats[type].speed||0.2;
    this.range=unitStats[type].range||25;
    this.role=(type==="archer")?"archer":(type==="healer")?"healer":"melee";
    if(type==="shaman") this.role="shaman";
    if(type==="phantom") this.role="phantom";
    this.color=(side==="player")? (type==="archer"?"cyan":type==="healer"?"green":"blue") :"red";
    const nameMap={swordsman:"ナ",archer:"弓",healer:"聖",goblin:"ゴ",orc:"オ",shaman:"シ",phantom:"フ",golem:"ゴレ"};
    this.label=nameMap[type]||"?";
    this.target=null; this.cooldown=0;
  }
  draw(){
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=(this.side==="player")?"white":"black";
    ctx.font="14px sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(this.label,this.x,this.y);
  }
  update(){
    if(this.target){
      if(this.target.hp<=0||!inMeleeRange(this,this.target)){this.target=null;} else {return;}
    }
    if(this.side==="player") this.y-=this.speed; else this.y+=this.speed;
  }
}

class Projectile{constructor(x,y,target,atk,color="white"){this.x=x;this.y=y;this.target=target;this.atk=atk;this.speed=3;this.active=true;this.color=color;}
  update(){if(!this.target||this.target.hp<=0){this.active=false;return;}let dx=this.target.x-this.x,dy=this.target.y-this.y;let dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<5){this.target.hp-=this.atk;hitMarks.push(new HitMark(this.target.x,this.target.y));this.active=false;}else{this.x+=(dx/dist)*this.speed;this.y+=(dy/dist)*this.speed;}}
  draw(){ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.x,this.y,4,0,Math.PI*2);ctx.fill();}}
class HealProjectile{constructor(x,y,target,amount){this.x=x;this.y=y;this.target=target;this.amount=amount;this.speed=3;this.active=true;}
  update(){if(!this.target||this.target.hp<=0){this.active=false;return;}let dx=this.target.x-this.x,dy=this.target.y-this.y;let dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<5){this.target.hp+=this.amount;hitMarks.push(new HealMark(this.target.x,this.target.y));this.active=false;}else{this.x+=(dx/dist)*this.speed;this.y+=(dy/dist)*this.speed;}}
  draw(){ctx.fillStyle="lime";ctx.beginPath();ctx.arc(this.x,this.y,4,0,Math.PI*2);ctx.fill();}}
class HitMark{constructor(x,y){this.x=x;this.y=y;this.life=15;}update(){this.life--;}draw(){ctx.lineWidth=3;ctx.strokeStyle="red";ctx.beginPath();ctx.moveTo(this.x-8,this.y-8);ctx.lineTo(this.x+8,this.y+8);ctx.moveTo(this.x+8,this.y-8);ctx.lineTo(this.x-8,this.y+8);ctx.stroke();ctx.lineWidth=1;}}
class HealMark{constructor(x,y){this.x=x;this.y=y;this.life=15;}update(){this.life--;}draw(){ctx.strokeStyle="lime";ctx.lineWidth=3;ctx.beginPath();ctx.arc(this.x,this.y,14,0,Math.PI*2);ctx.stroke();ctx.lineWidth=1;}}
class SwingMark{constructor(x,y,side){this.x=x;this.y=y;this.life=12;this.side=side;}update(){this.life--;}draw(){ctx.save();ctx.lineWidth=3;ctx.strokeStyle=(this.side==="player")?"#88f":"#f88";ctx.beginPath();ctx.arc(this.x,this.y,16,-Math.PI/3,0);ctx.stroke();ctx.beginPath();ctx.arc(this.x,this.y,12,0,Math.PI/3);ctx.stroke();ctx.restore();}}

function inMeleeRange(u1,u2){const laneDiff=Math.abs(u1.lane-u2.lane);const dy=Math.abs(u1.y-u2.y);if(laneDiff===0){return dy<=24;}else if(laneDiff===1){return dy<=20;}return false;}
function inUnitRange(u1,u2){let dx=(u1.lane-u2.lane)*(canvas.width/5);let dy=u1.y-u2.y;let dist=Math.sqrt(dx*dx+dy*dy);return dist<=u1.range;}

function startGame(){
  document.getElementById("menu").style.display="none";
  document.getElementById("title").style.display="none";
  document.getElementById("help").style.display="none";
  canvas.style.display="block";document.getElementById("ui").style.display="block";
  playerBaseHP=100;enemyBaseHP=100;playerUnits=[];enemyUnits=[];projectiles=[];hitMarks=[];swingMarks=[];
  canvas.onclick=(e)=>{if(!pendingUnitType)return;let rect=canvas.getBoundingClientRect();let lane=Math.floor((e.clientX-rect.left)/(canvas.width/5));playerUnits.push(new Unit(pendingUnitType,"player",lane,canvas.height-40));pendingUnitType=null;};
  setInterval(()=>{const enemyTypes=["goblin","orc","golem","shaman","phantom"];let type=enemyTypes[Math.floor(Math.random()*enemyTypes.length)];let lane=Math.floor(Math.random()*5);enemyUnits.push(new Unit(type,"enemy",lane,40));},4000);
  loop();
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#555";for(let i=1;i<5;i++){ctx.beginPath();ctx.moveTo(i*canvas.width/5,0);ctx.lineTo(i*canvas.width/5,canvas.height);ctx.stroke();}
  ctx.fillStyle="white";ctx.fillText(`自陣HP:${playerBaseHP}`,10,15);ctx.fillText(`敵陣HP:${enemyBaseHP}`,280,15);
  for(let u of [...playerUnits,...enemyUnits]){u.update();u.draw();}
  for(let p of playerUnits){for(let e of enemyUnits){if(inMeleeRange(p,e)){p.target=e;e.target=p;if(p.cooldown<=0){e.hp-=p.atk;hitMarks.push(new HitMark(e.x,e.y));swingMarks.push(new SwingMark(p.x,p.y,"player"));p.cooldown=30;}if(e.cooldown<=0){p.hp-=e.atk;hitMarks.push(new HitMark(p.x,p.y));swingMarks.push(new SwingMark(e.x,e.y,"enemy"));e.cooldown=40;}}else{if(p.role==="archer"&&inUnitRange(p,e)&&p.cooldown<=0){projectiles.push(new Projectile(p.x,p.y-12,e,p.atk,"white"));p.cooldown=60;}}}if(p.role==="healer"&&p.cooldown<=0){for(let ally of playerUnits){if(ally!==p&&ally.hp>0&&ally.hp<unitStats[ally.type].hp&&inUnitRange(p,ally)){projectiles.push(new HealProjectile(p.x,p.y-12,ally,p.atk));p.cooldown=90;}}}}
  for(let e of enemyUnits){if(e.target&&e.target.hp>0){}else{if(e.role==="shaman"&&e.cooldown<=0){if(playerUnits.length>0){let target=playerUnits[Math.floor(Math.random()*playerUnits.length)];if(inUnitRange(e,target)){projectiles.push(new Projectile(e.x,e.y+12,target,e.atk,"purple"));e.cooldown=80;}}}if(e.role==="phantom"&&e.cooldown<=0){if(playerUnits.length>0){let target=playerUnits[Math.floor(Math.random()*playerUnits.length)];if(inUnitRange(e,target)){projectiles.push(new Projectile(e.x,e.y+12,target,e.atk,"yellow"));e.cooldown=50;}}}}}
  for(let u of [...playerUnits,...enemyUnits]) if(u.cooldown>0) u.cooldown--;
  for(let pr of projectiles){pr.update();pr.draw();} projectiles=projectiles.filter(pr=>pr.active);
  for(let h of hitMarks){h.update();h.draw();} hitMarks=hitMarks.filter(h=>h.life>0);
  for(let s of swingMarks){s.update();s.draw();} swingMarks=swingMarks.filter(s=>s.life>0);
  playerUnits=playerUnits.filter(u=>u.hp>0&&u.y>0);
  enemyUnits=enemyUnits.filter(u=>u.hp>0&&u.y<canvas.height);
  for(let e of enemyUnits){if(e.y>=canvas.height-30){playerBaseHP-=e.atk;e.hp=0;}}
  for(let p of playerUnits){if(p.y<=30){enemyBaseHP-=p.atk;p.hp=0;}}
  if(playerBaseHP<=0){ctx.fillStyle="red";ctx.font="30px sans-serif";ctx.fillText("GAME OVER",100,300);return;}
  if(enemyBaseHP<=0){ctx.fillStyle="yellow";ctx.font="30px sans-serif";ctx.fillText("VICTORY!",120,300);return;}
  requestAnimationFrame(loop);
}

function chooseUnit(type){pendingUnitType=type;}
</script>
</body>
</html>
